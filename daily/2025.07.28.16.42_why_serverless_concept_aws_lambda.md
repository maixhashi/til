# なぜAWS Lambdaにおいてサーバーレスという概念が重要なのか

## What's this file?
> [!NOTE]
> **Why**
> 
> **なぜ**AWS Lambdaにおいてサーバーレスという概念が重要なのか

## Conclusion (忙しいとき向け)
> [!IMPORTANT]
> **Why** : **なぜ**AWS Lambdaにおいてサーバーレスという概念が重要なのか
> 
> **Answer** : サーバーレスは、インフラ管理の責任をクラウドプロバイダーに移し、開発者がビジネスロジックに集中できるようにするため。イベント駆動実行、自動スケーリング、従量課金モデルにより、運用の簡素化、コスト効率、開発速度の向上を実現するから。

## 目次
<details>
<summary>目次を開く</summary>

- [サーバーレスとは何か](#サーバーレスとは何か)
- [AWS Lambdaの動作原理](#aws-lambdaの動作原理)
- [サーバーレスアーキテクチャパターン](#サーバーレスアーキテクチャパターン)
- [従来型との比較](#従来型との比較)
- [サーバーレスの利点](#サーバーレスの利点)
- [サーバーレスの制約](#サーバーレスの制約)
- [ベストプラクティス](#ベストプラクティス)
- [関連](#関連)

</details>

## サーバーレスとは何か

### 基本概念
サーバーレスは、開発者がサーバーのプロビジョニング、スケーリング、管理を行うことなく、アプリケーションを構築・実行できるクラウドコンピューティングモデルです。

**重要**: 「サーバーレス」といっても、実際にはサーバーは存在します。ただし、その管理責任がクラウドプロバイダー（AWS）に移るという意味です。

### 従来のアプローチとの違い

```mermaid
graph LR
    subgraph "従来型（Spring）"
        direction TB
        A1[アプリコード]:::user
        A2[Spring]:::user
        A3[サーバー]:::user
        A4[JVM]:::user
        A5[OS]:::user
        A6[インフラ]:::user
        
        A1 --> A2
        A2 --> A3
        A3 --> A4
        A4 --> A5
        A5 --> A6
    end
    
    subgraph "サーバーレス（Lambda）"
        direction TB
        B1[関数コード]:::user
        B2[ランタイム]:::aws
        B3[実行環境]:::aws
        B4[OS]:::aws
        B5[インフラ]:::aws
        
        B1 --> B2
        B2 --> B3
        B3 --> B4
        B4 --> B5
    end
    
    classDef user fill:#ff9999,stroke:#333,stroke-width:2px
    classDef aws fill:#99ccff,stroke:#333,stroke-width:2px
```

#### 責任範囲の比較

```mermaid
graph TB
    subgraph "責任範囲の比較"
        subgraph "従来型"
            Traditional[あなたの責任<br/>━━━━━━━━━━<br/>アプリ<br/>フレームワーク<br/>サーバー<br/>OS<br/>インフラ]:::traditional
        end
        
        subgraph "サーバーレス"
            YourPart[あなたの責任<br/>━━━━━━━━━━<br/>関数コード]:::user
            AWSPart[AWSの責任<br/>━━━━━━━━━━<br/>ランタイム<br/>実行環境<br/>OS<br/>インフラ]:::aws
        end
    end
    
    classDef traditional fill:#ff9999,stroke:#333,stroke-width:2px
    classDef user fill:#ff9999,stroke:#333,stroke-width:2px
    classDef aws fill:#99ccff,stroke:#333,stroke-width:2px
```

#### 責任分担モデル（Mermaidダイアグラム）

```mermaid
graph LR
    subgraph "EC2での責任分担"
        direction TB
        EC2_You[あなたの責任<br/>━━━━━━━━━━<br/>アプリ<br/>Spring<br/>Tomcat<br/>JVM<br/>OS<br/>EC2設定]:::user
        EC2_AWS[AWSの責任<br/>━━━━━━━━━━<br/>仮想化<br/>物理サーバー<br/>データセンター]:::partial
    end
    
    subgraph "Lambdaでの責任分担"
        direction TB
        Lambda_You[あなたの責任<br/>━━━━━━━━━━<br/>関数コード]:::user
        Lambda_AWS[AWSの責任<br/>━━━━━━━━━━<br/>ランタイム<br/>実行環境<br/>サービス<br/>インフラ]:::aws
    end
    
    classDef user fill:#ff9999,stroke:#333,stroke-width:2px
    classDef partial fill:#ffcc99,stroke:#333,stroke-width:2px
    classDef aws fill:#99ccff,stroke:#333,stroke-width:2px
```

#### アプローチの変化（Mermaidダイアグラム）

```mermaid
graph LR
    subgraph "Before: モノリシック"
        MA[モノリシックアプリ<br/>Spring Boot]
        MS[単一サーバー<br/>24/7稼働]
        MD[単一データベース]
        
        MA --> MS
        MS --> MD
    end
    
    subgraph "After: サーバーレス"
        SF1[関数A<br/>ユーザー管理]
        SF2[関数B<br/>注文処理]
        SF3[関数C<br/>通知送信]
        
        API[API Gateway]
        DDB[DynamoDB]
        SQS[SQS Queue]
        
        API --> SF1
        API --> SF2
        SF2 --> SQS
        SQS --> SF3
        SF1 --> DDB
        SF2 --> DDB
    end
    
    MA -.移行.-> API
    MD -.移行.-> DDB
    
    style MA fill:#ffcc99
    style MS fill:#ffcc99
    style MD fill:#ffcc99
    style SF1 fill:#99ff99
    style SF2 fill:#99ff99
    style SF3 fill:#99ff99
    style API fill:#99ccff
    style DDB fill:#99ccff
    style SQS fill:#99ccff
```

## AWS Lambdaの動作原理

### 1. イベント駆動実行モデル

#### 従来のWebアプリケーション（Spring）
```java
@RestController
public class UserController {
    // サーバーは常時起動
    // リクエストを待ち受ける
    
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
}
```

#### Lambda関数
```python
def lambda_handler(event, context):
    # イベントが発生した時のみ実行
    # 実行後は環境が破棄される可能性
    
    user_id = event['pathParameters']['id']
    return {
        'statusCode': 200,
        'body': json.dumps(get_user(user_id))
    }
```

### 2. コンテナライフサイクル

#### Lambda実行環境の仕組み
```
初回リクエスト（コールドスタート）:
1. イベント発生
2. 新しいコンテナ作成
3. ランタイム初期化
4. 関数コードのロード
5. ハンドラー実行
6. レスポンス返却
時間: 100ms〜数秒

後続リクエスト（ウォームスタート）:
1. イベント発生
2. 既存コンテナを再利用
3. ハンドラー実行
4. レスポンス返却
時間: 数ms〜数十ms
```

#### コンテナライフサイクル（Mermaidダイアグラム）

```mermaid
graph TB
    subgraph "コールドスタート"
        CS1[イベント発生] --> CS2[コンテナ作成]
        CS2 --> CS3[ランタイム初期化]
        CS3 --> CS4[コードロード]
        CS4 --> CS5[ハンドラー実行]
        CS5 --> CS6[レスポンス]
        
        style CS2 fill:#ffcc99
        style CS3 fill:#ffcc99
        style CS4 fill:#ffcc99
    end
    
    subgraph "ウォームスタート"
        WS1[イベント発生] --> WS2[既存コンテナ確認]
        WS2 --> WS3[ハンドラー実行]
        WS3 --> WS4[レスポンス]
        
        style WS2 fill:#99ff99
    end
    
    CS6 -.コンテナ保持<br/>数分〜数十分.-> WS2
```

### 3. 実行環境の特徴

#### 一時的な環境
- **ステートレス**: 実行間で状態を保持しない
- **制限時間**: 最大15分で強制終了
- **メモリ**: 128MB〜10,240MB
- **CPU**: メモリに比例して割り当て

#### 分離された実行
- **サンドボックス**: 他の実行から隔離
- **読み取り専用**: /varと/tmp以外は読み取り専用
- **一時ストレージ**: /tmpに512MB

## サーバーレスアーキテクチャパターン

### 1. API Backend

```mermaid
graph LR
    Client[クライアント] --> APIGW[API Gateway]
    APIGW --> Lambda[Lambda関数]
    Lambda --> DDB[DynamoDB]
    Lambda --> External[外部API]
    
    style Lambda fill:#99ff99,stroke:#333,stroke-width:2px
    style APIGW fill:#99ccff,stroke:#333,stroke-width:2px
    style DDB fill:#ffcc99,stroke:#333,stroke-width:2px
```

### 2. ストリーム処理

```mermaid
graph LR
    Kinesis[Kinesis Stream] --> Lambda[Lambda関数]
    SQS[SQS Queue] --> Lambda
    Lambda --> S3[S3 Bucket]
    Lambda --> DDB[DynamoDB]
    
    style Lambda fill:#99ff99,stroke:#333,stroke-width:2px
    style Kinesis fill:#ff99cc,stroke:#333,stroke-width:2px
    style SQS fill:#ff99cc,stroke:#333,stroke-width:2px
    style S3 fill:#ffcc99,stroke:#333,stroke-width:2px
    style DDB fill:#ffcc99,stroke:#333,stroke-width:2px
```

### 3. 定期実行

```mermaid
graph LR
    EventBridge[EventBridge<br/>Cronルール] -->|定期トリガー| Lambda[Lambda関数]
    Lambda --> Batch[バッチ処理]
    Lambda --> DB[(データベース)]
    Lambda --> Report[レポート生成]
    
    style Lambda fill:#99ff99,stroke:#333,stroke-width:2px
    style EventBridge fill:#99ccff,stroke:#333,stroke-width:2px
    style Batch fill:#ffcc99,stroke:#333,stroke-width:2px
```

### 4. ファイル処理

```mermaid
graph LR
    S3Upload[S3<br/>ファイルアップロード] -->|イベントトリガー| Lambda[Lambda関数<br/>画像処理]
    Lambda -->|リサイズ| Process[画像リサイズ処理]
    Process --> S3Save[S3<br/>処理済み画像保存]
    Lambda --> Meta[メタデータ抽出]
    Meta --> DDB[DynamoDB<br/>メタデータ保存]
    
    style Lambda fill:#99ff99,stroke:#333,stroke-width:2px
    style S3Upload fill:#ffcc99,stroke:#333,stroke-width:2px
    style S3Save fill:#ffcc99,stroke:#333,stroke-width:2px
    style Process fill:#ccccff,stroke:#333,stroke-width:2px
```

### アーキテクチャパターン（Mermaidダイアグラム）

```mermaid
graph LR
    subgraph "1. API Backend"
        Client1[クライアント] --> APIGW[API Gateway]
        APIGW --> L1[Lambda]
        L1 --> DDB1[DynamoDB]
        L1 --> ExtAPI[外部API]
    end
    
    subgraph "2. ストリーム処理"
        Kinesis[Kinesis] --> L2[Lambda]
        SQS1[SQS] --> L2
        L2 --> S3A[S3]
        L2 --> DDB2[DynamoDB]
    end
    
    subgraph "3. 定期実行"
        EB[EventBridge<br/>Cron] --> L3[Lambda]
        L3 --> Batch[バッチ処理]
    end
    
    subgraph "4. ファイル処理"
        S3U[S3<br/>Upload] --> L4[Lambda<br/>画像処理]
        L4 --> S3S[S3<br/>保存]
    end
    
    style L1 fill:#99ff99
    style L2 fill:#99ff99
    style L3 fill:#99ff99
    style L4 fill:#99ff99
```

## 従来型との比較

### Spring Boot アプリケーション
```java
// 常時稼働するアプリケーション
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        // JVMが起動し、サーバーが立ち上がる
        // 終了するまで稼働し続ける
        SpringApplication.run(Application.class, args);
    }
}

// DIコンテナ、データベース接続プール等を管理
@Service
public class UserService {
    @Autowired
    private UserRepository repository;
    
    // 複数のリクエストで共有される
}
```

### Lambda関数
```python
# イベントごとに独立して実行
import json
import boto3

# グローバル変数は再利用される可能性
dynamodb = boto3.resource('dynamodb')

def lambda_handler(event, context):
    # この関数が実行の単位
    # 各実行は独立している
    
    table = dynamodb.Table('users')
    response = table.get_item(Key={'id': event['id']})
    
    return {
        'statusCode': 200,
        'body': json.dumps(response['Item'])
    }
```

## サーバーレスの利点

### 1. 運用の簡素化
- **自動スケーリング**: トラフィックに応じて自動調整
- **高可用性**: マルチAZで自動的に実行
- **メンテナンス不要**: パッチ適用、アップデート不要

### 2. コスト効率
```
従来型（EC2上のSpring）:
月額固定費 = インスタンス料金 × 24時間 × 30日

Lambda:
月額変動費 = (実行時間 × メモリ) + リクエスト数
アイドル時 = 0円
```

### 3. 開発速度
- **インフラ設定不要**: コードをアップロードするだけ
- **環境構築不要**: ランタイムは提供される
- **即座にスケール**: 設定なしで自動スケール

## サーバーレスの制約

### 1. 実行時間制限
- **最大15分**: 長時間処理には不向き
- **解決策**: Step Functions、ECS/Fargateとの組み合わせ

### 2. コールドスタート
- **初回実行の遅延**: 100ms〜数秒
- **解決策**: Provisioned Concurrency、定期的なウォームアップ

### 3. ローカル開発
- **実環境との差異**: ローカルでの完全な再現が困難
- **解決策**: SAM、LocalStack、コンテナイメージ

### 4. ベンダーロックイン
- **AWS固有の機能**: 他クラウドへの移行が困難
- **解決策**: 抽象化レイヤー、標準的なランタイム使用

## ベストプラクティス

### 1. 関数の設計
```python
# 良い例：単一責任、小さな関数
def process_order(event, context):
    order = parse_order(event)
    validate_order(order)
    save_order(order)
    return success_response(order.id)

# 避けるべき例：大きすぎる関数
def do_everything(event, context):
    # 認証、検証、DB操作、外部API呼び出し...
    # 1000行のコード
```

### 2. 依存関係の管理
- **最小限の依存**: デプロイサイズを小さく
- **レイヤーの活用**: 共通ライブラリの共有
- **ネイティブ依存**: Lambda環境に合わせたビルド

### 3. エラーハンドリング
```python
def lambda_handler(event, context):
    try:
        result = process_data(event)
        return {
            'statusCode': 200,
            'body': json.dumps(result)
        }
    except ValidationError as e:
        # DLQに送信される
        raise
    except Exception as e:
        # CloudWatchにログ記録
        logger.error(f"Unexpected error: {e}")
        return {
            'statusCode': 500,
            'body': json.dumps({'error': 'Internal server error'})
        }
```

## 関連
- [サーバー管理の複雑さとAWS Lambdaによる解決](/Users/shota-hashimoto/til/daily/2025.07.28.16.40_why_server_complexity_vs_aws_lambda.md)
- [AWS Lambdaとは](/Users/shota-hashimoto/til/daily/2025.07.28.17.36_what_is-aws-lambda.md)
- [AWS Fargateとは](/Users/shota-hashimoto/til/daily/2025.07.28.16.50_what_is-aws-fargate.md)
- [AWS Lambdaベストプラクティス](https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html)
- [Serverless Architectures](https://martinfowler.com/articles/serverless.html) - Martin Fowler