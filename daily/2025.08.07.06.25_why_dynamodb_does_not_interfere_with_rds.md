# なぜDynamoDBとRDSは干渉しないのか

## What's this file?
> [!NOTE]
> **Why**
> 
> **なぜ**DynamoDBとRDS（Amazon Relational Database Service）は干渉しないのか

## Conclusion (忙しいとき向け)
> [!IMPORTANT]
> **Why** : **なぜ**DynamoDBとRDSは干渉しないのか
> 
> **Answer** : 異なるサービスレイヤー、独立したネットワーク構成、別々の用途とアクセスパターンを持つため、技術的にもリソース的にも完全に分離されているから

## 目次
<details>
<summary>目次を開く</summary>

- [アーキテクチャレベルでの分離](#アーキテクチャレベルでの分離)
- [ネットワークレベルでの独立性](#ネットワークレベルでの独立性)
- [リソースの競合がない理由](#リソースの競合がない理由)
- [用途の明確な違い](#用途の明確な違い)
- [実際のプロジェクトでの共存例](#実際のプロジェクトでの共存例)

</details>

## アーキテクチャレベルでの分離

### サービス階層の違い

```mermaid
graph TB
    subgraph "アプリケーション層"
        APP[example-project-app]
    end
    
    subgraph "インフラ管理層"
        TF[Terraform]
    end
    
    subgraph "AWS Services"
        subgraph "マネージドサービス（VPC外）"
            DDB[DynamoDB<br/>ステートロック用]
            S3[S3<br/>ステートファイル保存]
        end
        
        subgraph "VPC内サービス"
            RDS[(RDS<br/>アプリケーションDB)]
            ECS[ECS Fargate<br/>アプリケーション実行]
        end
    end
    
    TF -->|API| DDB
    TF -->|API| S3
    APP -->|Private Network| RDS
    ECS -->|Private Network| RDS
    
    style DDB fill:#f96,stroke:#333,stroke-width:2px
    style RDS fill:#9cf,stroke:#333,stroke-width:2px
```

### 管理レベルの違い

| 特性 | DynamoDB | RDS |
|------|----------|-----|
| 管理レベル | フルマネージド | マネージド |
| インフラ管理 | AWS完全管理 | 一部ユーザー設定可能 |
| スケーリング | 自動 | 手動/自動（Aurora） |
| パッチ適用 | 自動（透過的） | メンテナンスウィンドウ |

## ネットワークレベルでの独立性

### DynamoDBのネットワーク構成

```mermaid
graph LR
    subgraph "インターネット"
        CLIENT[Terraformクライアント]
    end
    
    subgraph "AWS Public Services"
        ENDPOINT[DynamoDB API Endpoint<br/>dynamodb.ap-northeast-1.amazonaws.com]
        DDB_SERVICE[DynamoDB Service]
    end
    
    CLIENT -->|HTTPS/443| ENDPOINT
    ENDPOINT --> DDB_SERVICE
    
    style DDB_SERVICE fill:#f96,stroke:#333,stroke-width:2px
```

### RDSのネットワーク構成

```mermaid
graph LR
    subgraph "VPC (10.0.0.0/16)"
        subgraph "Private Subnet"
            ECS[ECS Tasks]
            RDS[(RDS Instance<br/>10.0.2.100)]
        end
        
        subgraph "Security Groups"
            SG_ECS[sg-ecs-tasks]
            SG_RDS[sg-rds]
        end
    end
    
    ECS -->|Port 5432| RDS
    SG_ECS -.->|Allow| SG_RDS
    
    style RDS fill:#9cf,stroke:#333,stroke-width:2px
```

### ネットワーク分離の要点

1. **DynamoDB**: インターネット経由のAPI呼び出し
2. **RDS**: VPC内のプライベート通信
3. **接点なし**: 物理的にも論理的にも交差しない

## リソースの競合がない理由

### コンピューティングリソース

```mermaid
pie title "リソース利用の分離"
    "DynamoDB (AWS管理)" : 100
    "RDS (専用インスタンス)" : 100
    "ECS (Fargate)" : 100
```

**分離のポイント：**
- DynamoDB: AWSの共有インフラで実行
- RDS: 専用のEC2インスタンス上で実行
- リソースプールが完全に別

### ストレージの独立性

| 項目 | DynamoDB | RDS |
|------|----------|-----|
| ストレージタイプ | SSD（自動管理） | EBS（gp3/io1） |
| 容量管理 | 無制限（自動） | 事前割り当て |
| IOPS | 自動調整 | 設定値固定 |
| バックアップ | 別システム | スナップショット |

### メモリ・CPU利用

```yaml
# RDSの例（terraform設定）
instance_class = "db.t3.medium"  # 2 vCPU, 4 GiB RAM

# DynamoDBの例
# CPUやメモリの指定なし（AWS管理）
read_capacity_units = 5
write_capacity_units = 5
```

## 用途の明確な違い

### DynamoDBの用途（一般的なプロジェクト）

```hcl
# backend.tf での利用
terraform {
  backend "s3" {
    dynamodb_table = "terraform-state-lock"  # ロック管理のみ
  }
}
```

**特徴：**
- Terraformステートのロック管理専用
- アプリケーションからはアクセスなし
- 一時的なロック情報のみ保存

### RDSの用途（一般的なプロジェクト）

```sql
-- アプリケーションデータの保存
CREATE TABLE projects (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255),
    created_at TIMESTAMP
);

CREATE TABLE measurements (
    id SERIAL PRIMARY KEY,
    project_id INTEGER REFERENCES projects(id),
    data JSONB,
    measured_at TIMESTAMP
);
```

**特徴：**
- ビジネスデータの永続化
- トランザクション処理
- 複雑なクエリとリレーション

## 実際のプロジェクトでの共存例

### example-projectプロジェクトの構成

```mermaid
graph TD
    subgraph "開発・運用フロー"
        DEV[開発者] -->|terraform apply| TF[Terraform]
        TF -->|State Lock| DDB[DynamoDB]
        TF -->|Provision| INFRA[AWSインフラ]
    end
    
    subgraph "アプリケーションフロー"
        USER[エンドユーザー] -->|HTTPS| CF[CloudFront]
        CF --> ALB[ALB]
        ALB --> ECS[ECS Tasks]
        ECS -->|Query| RDS[(RDS)]
    end
    
    style DDB fill:#f96,stroke:#333,stroke-width:2px
    style RDS fill:#9cf,stroke:#333,stroke-width:2px
```

### 干渉が起きない理由のまとめ

1. **タイミングの違い**
   - DynamoDB: インフラ構築時のみ
   - RDS: アプリケーション実行時

2. **アクセス元の違い**
   - DynamoDB: Terraformクライアント
   - RDS: ECSタスク（アプリケーション）

3. **ライフサイクルの違い**
   - DynamoDB: 数秒間のロック
   - RDS: 永続的なデータ保存

4. **スケーリング特性の違い**
   - DynamoDB: 自動（影響なし）
   - RDS: 計画的（メンテナンス）

### 共存のベストプラクティス

```mermaid
graph LR
    subgraph "インフラ管理"
        A[Terraform] --> B[DynamoDB<br/>最小構成]
    end
    
    subgraph "アプリケーション"
        C[App] --> D[RDS<br/>適切なサイジング]
    end
    
    E[監視] --> B
    E[監視] --> D
    
    style B fill:#fcc,stroke:#333,stroke-width:1px
    style D fill:#ccf,stroke:#333,stroke-width:1px
```

**ポイント：**
- 各サービスを独立して監視
- リソース使用率を個別に最適化
- 障害時の影響範囲が限定的

## 関連
- [AWS DynamoDB と RDS の使い分け](https://aws.amazon.com/jp/nosql/vs-rds/)
- [Terraform Backend Best Practices](https://www.terraform.io/docs/language/settings/backends/configuration.html)
- [AWS Well-Architected Framework](https://aws.amazon.com/jp/architecture/well-architected/)