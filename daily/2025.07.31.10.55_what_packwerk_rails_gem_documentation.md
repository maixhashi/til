# Packwerk Rails Gem説明書

## 概要

Packwerkは、Shopifyが開発したRuby gemで、Railsアプリケーションのモジュール化と境界管理を実現するツールです。モノリシックなRailsアプリケーションに軽量なモジュール構造を導入し、アーキテクチャの境界を強制することができます。

## 主な目的と解決する課題

### 課題
- モノリシックなコードベースでは、開発者が変更を加える際に予期しない影響が発生しやすい
- 関係のないテストが壊れたり、2000行を超える巨大クラスが生まれやすい
- スパゲッティコードや責任過多なクラスなどのアンチパターンが発生
- コードベースの開発、保守、理解が困難になり、新機能の追加が難しくなる

### 解決策
Packwerkは、Rails Enginesよりも軽量で柔軟な代替手段として、段階的な移行を可能にし、コードが十分にリファクタリングされて結合度が低くなった時点でのみモジュール境界を強制します。

## 主な機能

### 1. 違反の検出

Packwerkは主に2種類の違反を検出します：

#### 依存関係違反（Dependency Violations）
- パッケージが、依存関係として宣言されていない別のパッケージのプライベート定数を参照する場合に発生

#### プライバシー違反（Privacy Violations）  
- 外部の定数がパッケージのプライベート定数を参照する場合に発生
- ただし、`app/public`フォルダ内の定数は公開されており、アクセスしても違反にならない

### 2. 静的解析

- ConstantResolverというShopifyのオープンソースgemを使用して、アプリケーション内の定数を静的に解析
- Zeitwerk（Railsのコードローダー）と同じ前提を使用して定数のファイル位置を推測

### 3. CI/CD統合

- CIパイプラインに統合して、新しい違反がマージされるのを防止
- ローカルでもパッケージ関連のチェックを実行可能

### 4. 段階的な移行サポート

- 既存の違反を「deprecated references」リストとして生成
- 開発者のワークフローを妨げることなく、新しい違反の追加を防止
- このリストを使用して、よりクリーンなアーキテクチャへの移行を支援

## 使用方法の基本

### パッケージの定義
各パッケージは`package.yml`ファイルで定義され、以下の情報を含みます：
- 依存関係の宣言
- プライバシー設定
- メタデータ

### コマンド
- `packwerk check` - 違反をチェック
- `packwerk update-deprecations` - deprecated referencesリストを更新
- `packwerk validate` - 設定の検証

## メリット

1. **柔軟性**: 必要に応じて依存関係を追加できるが、それらを可視化し、アーキテクチャ設計の潜在的な欠陥を明らかにする

2. **段階的移行**: 時間をかけてモジュール化を進めることができ、コードが完全にリファクタリングされるまで境界の強制を延期できる

3. **既存コードとの共存**: レガシーな大規模Railsアプリでも、既存の違反を許容しながら新しい違反を防ぐことができる

## 制限事項と考慮点

### 実装上の問題
- プライバシーチェックには`app/public`ディレクトリが必要で、Railsの慣習を破る
- ファイルの配置場所について混乱が生じやすい
- 公開APIのドキュメント化が不十分になりがち

### 設計上の課題
- パッケージとその関係性の選択が難しい（特に大規模なコードベースで）
- Packwerk自体はガイダンスを提供せず、開発者の判断に委ねられる
- 不適切なパッケージ設計は、後の変更に大きなコストがかかる可能性がある

### APIデザインツールとしての限界
- 本来の意図を超えて、APIデザインツールとして使われることがあるが、そのための機能は十分でない

## 導入時の推奨事項

1. **小さく始める**: 最初は少数のパッケージから始め、徐々に拡大する
2. **明確な境界**: パッケージの責任範囲を明確に定義する
3. **チーム教育**: 開発チーム全体でPackwerkの目的と使用方法を理解する
4. **継続的な改善**: deprecated referencesを定期的に見直し、削減する

## まとめ

Packwerkは、Railsアプリケーションにモジュール構造を導入し、アーキテクチャの境界を管理するための強力なツールです。段階的な移行をサポートし、既存のコードベースを破壊することなく、より良いアーキテクチャへの道筋を提供します。ただし、適切なパッケージ設計と継続的な管理が成功の鍵となります。