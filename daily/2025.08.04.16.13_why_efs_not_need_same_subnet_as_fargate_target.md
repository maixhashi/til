# なぜEFSマウントターゲットはFargateタスクと同じサブネットに存在する必要がないのか

## What's this file?
> [!NOTE]
> **Why**
> 
> **なぜ**EFSマウントターゲットはFargateタスクと同じサブネットに存在する必要がないのか

## Conclusion (忙しいとき向け)
> [!IMPORTANT]
> **Why** : **なぜ**EFSマウントターゲットはFargateタスクと同じサブネットに存在する必要がないのか
> 
> **Answer** : EFSマウントターゲットは同一VPC内であればNFSプロトコルを通じてサブネットをまたいでアクセス可能であり、むしろ別サブネットに配置することでネットワーク分離とセキュリティ向上が図れるため

## 目次
<details>
<summary>目次を開く</summary>

- [VPC内ネットワーキングの基本原則](#vpc内ネットワーキングの基本原則)
- [EFSとFargateの接続メカニズム](#efsとfargateの接続メカニズム)
- [別サブネット配置のメリット](#別サブネット配置のメリット)
- [実装パターンとベストプラクティス](#実装パターンとベストプラクティス)

</details>

## VPC内ネットワーキングの基本原則

### VPC内の通信ルール

```mermaid
graph TB
    subgraph "VPC (10.0.0.0/16)"
        subgraph "コンピュートサブネット群"
            subgraph "Subnet A (10.0.1.0/24)"
                FG1[Fargate Task 1<br/>10.0.1.10]
            end
            subgraph "Subnet B (10.0.2.0/24)"
                FG2[Fargate Task 2<br/>10.0.2.10]
            end
        end
        
        subgraph "ストレージサブネット群"
            subgraph "Subnet C (10.0.10.0/24)"
                MT1[EFS Mount Target<br/>10.0.10.10]
            end
            subgraph "Subnet D (10.0.11.0/24)"
                MT2[EFS Mount Target<br/>10.0.11.10]
            end
        end
        
        RT[ルートテーブル<br/>10.0.0.0/16 → local]
    end
    
    FG1 <-->|NFS通信可能| MT1
    FG1 <-->|NFS通信可能| MT2
    FG2 <-->|NFS通信可能| MT1
    FG2 <-->|NFS通信可能| MT2
    
    style FG1 fill:#9f9,stroke:#333,stroke-width:2px
    style FG2 fill:#9f9,stroke:#333,stroke-width:2px
    style MT1 fill:#9ff,stroke:#333,stroke-width:2px
    style MT2 fill:#9ff,stroke:#333,stroke-width:2px
```

### 基本原則
1. **同一VPC内通信**: デフォルトで全サブネット間で通信可能
2. **ローカルルート**: VPC CIDRへのルートは自動的に設定
3. **プロトコル非依存**: TCP/UDP含むすべてのプロトコルで通信可能
4. **セキュリティグループ制御**: 通信はSGとNACLで制御

## EFSとFargateの接続メカニズム

### NFSプロトコルによる接続

```mermaid
sequenceDiagram
    participant FT as Fargate Task<br/>(10.0.1.10)
    participant DNS as VPC DNS<br/>リゾルバー
    participant RT as ルートテーブル
    participant MT as EFS Mount Target<br/>(10.0.10.10)
    participant EFS as EFSファイルシステム
    
    FT->>DNS: EFS DNS名を解決
    Note over DNS: availability-zone.fs-xxxxx<br/>.efs.region.amazonaws.com
    DNS-->>FT: マウントターゲットIP返却
    FT->>RT: 10.0.10.10へのルート確認
    RT-->>FT: ローカルルート (同一VPC)
    FT->>MT: NFS接続 (Port 2049)
    MT->>EFS: ファイルシステムアクセス
    EFS-->>FT: マウント成功
```

### 技術的な通信要件

```mermaid
graph LR
    subgraph "必要な要件"
        REQ1[同一VPC内]
        REQ2[ルーティング可能]
        REQ3[セキュリティグループ許可]
        REQ4[NACLs許可]
    end
    
    subgraph "不要な要件"
        NREQ1[同一サブネット ❌]
        NREQ2[同一AZ ❌]
        NREQ3[専用ルート設定 ❌]
    end
    
    style REQ1 fill:#9f9,stroke:#333,stroke-width:2px
    style REQ2 fill:#9f9,stroke:#333,stroke-width:2px
    style REQ3 fill:#9f9,stroke:#333,stroke-width:2px
    style REQ4 fill:#9f9,stroke:#333,stroke-width:2px
    style NREQ1 fill:#f99,stroke:#333,stroke-width:2px
    style NREQ2 fill:#f99,stroke:#333,stroke-width:2px
    style NREQ3 fill:#f99,stroke:#333,stroke-width:2px
```

## 別サブネット配置のメリット

### ネットワーク分離による利点

```mermaid
graph TB
    subgraph "推奨アーキテクチャ"
        subgraph "アプリケーション層"
            subgraph "App Subnet 1"
                FG1[Fargate Service A]
            end
            subgraph "App Subnet 2"
                FG2[Fargate Service B]
            end
        end
        
        subgraph "ストレージ層"
            subgraph "Storage Subnet 1"
                MT[EFS Mount Target]
                RDS[(RDS)]
            end
            subgraph "Storage Subnet 2"
                CACHE[ElastiCache]
            end
        end
        
        subgraph "管理層"
            subgraph "Management Subnet"
                BASTION[踏み台サーバー]
            end
        end
    end
    
    FG1 --> MT
    FG2 --> MT
    FG1 --> RDS
    FG2 --> CACHE
    BASTION -.->|管理アクセス| MT
    
    style MT fill:#9ff,stroke:#333,stroke-width:3px
    style FG1 fill:#9f9,stroke:#333,stroke-width:2px
    style FG2 fill:#9f9,stroke:#333,stroke-width:2px
```

### メリット一覧

| カテゴリ | メリット | 詳細 |
|---------|----------|------|
| セキュリティ | 層別アクセス制御 | アプリ層とストレージ層を分離してセキュリティ強化 |
| 管理性 | 明確な責任分界 | サブネット単位でのリソース管理が容易 |
| 拡張性 | 独立したスケーリング | アプリとストレージを独立して拡張可能 |
| 監視 | トラフィック分析 | VPC Flow Logsで層間通信を可視化 |
| コスト | AZ内通信の最適化 | 同一AZ内のMTを優先的に使用してコスト削減 |

## 実装パターンとベストプラクティス

### 推奨構成パターン

```mermaid
graph LR
    subgraph "パターン1: 層別分離"
        P1APP[アプリサブネット]
        P1STG[ストレージサブネット]
        P1APP -->|推奨| P1STG
    end
    
    subgraph "パターン2: AZ別分離"
        P2AZ1[AZ-1 統合サブネット]
        P2AZ2[AZ-2 統合サブネット]
        P2AZ1 <-->|許容| P2AZ2
    end
    
    subgraph "パターン3: 混在配置"
        P3MIX[混在サブネット<br/>Fargate + EFS MT]
        P3MIX -->|非推奨| P3MIX
    end
    
    style P1STG fill:#9f9,stroke:#333,stroke-width:3px
    style P2AZ1 fill:#ff9,stroke:#333,stroke-width:2px
    style P3MIX fill:#f99,stroke:#333,stroke-width:2px
```

### Terraformによる実装例

```hcl
# VPCとサブネット定義
locals {
  vpc_cidr = "10.0.0.0/16"
  azs      = ["ap-northeast-1a", "ap-northeast-1c"]
}

# アプリケーション用サブネット
resource "aws_subnet" "app" {
  count             = length(local.azs)
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.${count.index + 1}.0/24"
  availability_zone = local.azs[count.index]
  
  tags = {
    Name = "app-subnet-${local.azs[count.index]}"
    Type = "application"
  }
}

# ストレージ用サブネット（EFSマウントターゲット配置用）
resource "aws_subnet" "storage" {
  count             = length(local.azs)
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.${count.index + 10}.0/24"
  availability_zone = local.azs[count.index]
  
  tags = {
    Name = "storage-subnet-${local.azs[count.index]}"
    Type = "storage"
  }
}

# EFSマウントターゲット（ストレージサブネットに配置）
resource "aws_efs_mount_target" "main" {
  count           = length(local.azs)
  file_system_id  = aws_efs_file_system.main.id
  subnet_id       = aws_subnet.storage[count.index].id
  security_groups = [aws_security_group.efs_mt.id]
}

# Fargateタスク定義（アプリケーションサブネットで実行）
resource "aws_ecs_service" "app" {
  name            = "app-service"
  cluster         = aws_ecs_cluster.main.id
  task_definition = aws_ecs_task_definition.app.arn
  
  network_configuration {
    subnets         = aws_subnet.app[*].id  # アプリサブネット
    security_groups = [aws_security_group.fargate.id]
  }
}

# セキュリティグループ（Fargate → EFS通信許可）
resource "aws_security_group_rule" "fargate_to_efs" {
  type                     = "egress"
  from_port                = 2049
  to_port                  = 2049
  protocol                 = "tcp"
  source_security_group_id = aws_security_group.efs_mt.id
  security_group_id        = aws_security_group.fargate.id
  description              = "Allow NFS to EFS mount targets"
}

resource "aws_security_group_rule" "efs_from_fargate" {
  type                     = "ingress"
  from_port                = 2049
  to_port                  = 2049
  protocol                 = "tcp"
  source_security_group_id = aws_security_group.fargate.id
  security_group_id        = aws_security_group.efs_mt.id
  description              = "Allow NFS from Fargate tasks"
}
```

### パフォーマンス最適化のポイント

#### EFS接続の最適化設定

**DNS設定**
- AZごとのマウントターゲットDNS名を使用
- 例: `us-east-1a.fs-xxxxx.efs.us-east-1.amazonaws.com`

**マウントオプション**

| オプション | 値 | 説明 |
|----------|-----|------|
| nfsvers | 4.1 | NFSバージョン指定 |
| rsize | 1048576 | 読み取りバッファサイズ |
| wsize | 1048576 | 書き込みバッファサイズ |
| hard | - | ハードマウント |
| timeo | 600 | タイムアウト設定 |
| retrans | 2 | 再送信回数 |

**ネットワーク最適化**
- 同一AZ内のマウントターゲットを優先
- クロスAZ通信は障害時のフェイルオーバー用

### トラブルシューティングチェックリスト

1. **接続できない場合**
   - [ ] FargateタスクとEFSマウントターゲットが同一VPC内か
   - [ ] セキュリティグループでNFS (2049/tcp)が許可されているか
   - [ ] サブネットのルートテーブルが正しく設定されているか
   - [ ] NACLsでNFSトラフィックがブロックされていないか

2. **パフォーマンスが悪い場合**
   - [ ] 同一AZ内のマウントターゲットを使用しているか
   - [ ] 適切なマウントオプションが設定されているか
   - [ ] EFSのパフォーマンスモードが適切か

## 関連
- [AWS EFS with Fargate統合ガイド](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/fargate-efs.html)
- [VPCのサブネット設計ベストプラクティス](https://docs.aws.amazon.com/vpc/latest/userguide/configure-subnets.html)
- [EFSパフォーマンス最適化](https://docs.aws.amazon.com/efs/latest/ug/performance.html)