# Packs-Rails Gem説明書

## 概要

packs-railsは、大規模なRailsモノリスアプリケーションを段階的に分割・モジュール化するための規約とツールを提供するgemです。Ruby at Scaleエコシステムの一部として、Gustoによって開発され、packwerkと連携してRailsアプリケーションのモジュール化を容易にします。

## 背景と哲学

### なぜpacks-railsが必要か
- **Ruby gemの限界**: gemはRubyコードのパッケージング・配布には優れているが、既存のモノリスからの段階的な切り出しには重すぎる
- **段階的改善**: すべてを一度にgemに切り出すのではなく、概念的な境界を持ちながら徐々にモジュール化を進める
- **Rails固有の課題**: autoloadパス、ルーティング、エンジン機能など、Rails特有の設定を自動化

### packsの位置づけ
```
モノリスコード → packs（モジュール化） → gem（完全な独立）
```

## Ruby at Scaleエコシステム

### 主要コンポーネント

#### 1. **packs**（基盤）
- モジュール化の基本仕様を定義
- アプリケーションの概念的境界を表現
- gemへの移行前の中間段階として機能

#### 2. **packs-rails**（Rails統合）
- RailsのAutoload Pathsを自動設定
- Rails固有の機能（ルーティング、エンジン）をサポート
- 追加設定なしで即座に使用可能

#### 3. **packwerk**（依存関係管理）
- Rubyの定数参照をグラフとして解析
- `package.yml`による宣言的な制約定義
- 違反を`package_todo.yml`として出力

#### 4. **pack_stats**（メトリクス収集）
- モジュール化の進捗を統計として収集
- DataDogなどの監視システムへレポート
- 客観的な改善指標を提供

#### 5. **rubocop-packs**（コード規約）
- packs標準に準拠したRubocopルール集
- モジュール化のベストプラクティスを強制
- 一貫性のあるコード構造を維持

#### 6. **visualize_packs**（可視化）
- パッケージ構造を視覚的に表現
- 意図した構造と実際の構造の比較
- 依存関係の複雑さを把握

## 主な機能

### 1. ルーティングの分割

各packごとにルーティングファイルを作成可能：

```ruby
# packs/my_domain/config/routes/my_domain.rb
resources :my_resource

# config/routes.rb
Rails.application.routes.draw do
  draw(:my_domain)  # Rails 6.1+で利用可能
end
```

### 2. Rails Engineサポート

`package.yml`に`engine: true`を追加することで、packをRails Engineとして機能させることが可能：

```yaml
# packs/my_domain/package.yml
enforce_dependencies: true
enforce_privacy: true
engine: true  # Railsエンジンとして動作
```

これにより：
- 自動的な名前空間の設定
- 名前空間の分離
- エンジン固有の機能の利用

### 3. RSpecインテグレーション

`.rspec`ファイルに以下を追加：
```
--require packs/rails/rspec
```

実行例：
```bash
# アプリケーション全体のテストを実行
rspec

# 特定のテストファイルを実行
rspec spec/some/specific_spec.rb

# 特定のpackとその配下のpackのテストを実行
rspec packs/foobar
```

### 4. FactoryBotインテグレーション

各packの`[spec|test]/factories`ディレクトリが自動的に`config.factory_bot.definition_file_paths`に追加されます。

### 5. Springインテグレーション

```ruby
Packs::Specification::Configuration.fetch.pack_paths.each do |dir|
  Dir["#{dir}/package.yml"].each do |package_yml|
    Spring.watch(package_yml)
  end
end
```

## アプリケーション構造例

### 基本構造
```
.
├── package.yml              # ルートレベルのpack定義
├── app/                     # パッケージ化されていないコード
│   ├── models/
│   ├── controllers/
│   └── views/
├── packs/                   # モジュール化されたコード
│   ├── authentication/
│   │   ├── package.yml
│   │   ├── app/
│   │   │   ├── models/
│   │   │   ├── controllers/
│   │   │   └── services/
│   │   ├── config/
│   │   │   └── routes/
│   │   └── spec/
│   ├── payments/
│   │   ├── package.yml
│   │   └── app/
│   └── orders/
│       ├── package.yml
│       └── app/
└── config/
    └── routes.rb
```

### package.yml の例
```yaml
# packs/authentication/package.yml
enforce_dependencies: true
enforce_privacy: true
dependencies:
  - packs/shared
public_path: app/public/
```

## Packwerkとの連携

### チェッカーの仕組み
1. **参照の解析**: Ruby定数への各参照を分析
2. **チェッカーの適用**: 各チェッカーが独自のルールで違反を判定
3. **違反の記録**: 検出された違反を`package_todo.yml`に記録

### 主なチェッカー
- **依存関係チェッカー**: 明示的な依存関係なしの参照を違反とする
- **プライバシーチェッカー**: プライベートAPIへの参照を違反とする

## 導入手順

### 1. インストール
```ruby
# Gemfile
gem 'packs-rails'
```

### 2. 初期設定
```bash
bundle install
bin/rails generate packs:install
```

### 3. 最初のpackの作成
```bash
bin/packs create packs/my_first_pack
```

### 4. コードの移動
既存のコードを新しいpackに移動し、依存関係を整理

### 5. 違反の確認と修正
```bash
bin/packwerk check
bin/packwerk update-todo
```

## ベストプラクティス

### 1. 段階的な移行
- 小さなpackから始める
- 明確な境界を持つ機能から切り出す
- 完璧を求めず、継続的に改善

### 2. 依存関係の管理
- 循環依存を避ける
- 公開APIを明確に定義
- 必要最小限の依存関係を維持

### 3. チームでの運用
- pack所有者を明確にする
- レビュープロセスを確立
- メトリクスで進捗を追跡

### 4. 命名規則
- ドメインに基づいた名前を使用
- 一貫性のある階層構造
- 将来の分割を考慮した設計

## 利点と課題

### 利点
- **段階的モジュール化**: 一度にすべてを変更する必要なし
- **Rails統合**: Rails固有の機能をフルサポート
- **開発効率**: 自動設定により追加作業を最小化
- **可視化**: 依存関係と進捗を可視化
- **チーム分離**: 各packを独立して開発可能

### 課題
- **学習曲線**: 新しい概念と規約の理解が必要
- **初期設定**: 既存コードの整理に時間がかかる
- **規律の必要性**: チーム全体での一貫した運用が重要
- **パフォーマンス**: 大規模アプリでは解析に時間がかかる場合がある

## まとめ

packs-railsは、大規模なRailsアプリケーションを段階的にモジュール化するための実践的なソリューションです。Gustoの実際の経験から生まれたこのツールチェーンは、理想的な最終状態（完全にモジュール化されたアプリケーション）への現実的な道筋を提供します。完璧を求めるのではなく、継続的な改善を通じて、より保守性の高いコードベースを実現することができます。